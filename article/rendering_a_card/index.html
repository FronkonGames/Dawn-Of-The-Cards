<!doctype html><html itemscope itemtype=https://schema.org/WebPage class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=siteBaseUrl content="https://fronkongames.github.io/Dawn-Of-The-Cards/"><meta name=author content="Martin Bustos"><meta name=description content="A devblog about the development of 'Dawn Of The Cards'."><meta name=keywords content="devblog,blog,gamedev,gamedevelopment,indiedev,unity,unity3d,roguelike,deckbuilding,zombie,zombies,dawn,cards"><meta name=generator content="Hugo 0.118.2"><title>Rendering A Card In URP üñåÔ∏è | Dawn Of The Cards - Fronkon Games</title><meta itemprop=name content="Rendering A Card In URP üñåÔ∏è"><meta itemprop=description content="Rendering A Card In URP üñåÔ∏è - A devblog about the development of 'Dawn Of The Cards'."><meta property="og:title" content="Rendering A Card In URP üñåÔ∏è"><meta property="og:description" content="Rendering A Card In URP üñåÔ∏è - A devblog about the development of 'Dawn Of The Cards'."><meta property="og:image" content="https://fronkongames.github.io/Dawn-Of-The-Cards/"><meta property="og:url" content="https://fronkongames.github.io/Dawn-Of-The-Cards/article/rendering_a_card/"><meta property="og:site_name" content="Dawn Of The Cards - Fronkon Games"><meta property="og:type" content="article"><link rel=apple-touch-icon sizes=152x152 href=/Dawn-Of-The-Cards/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/Dawn-Of-The-Cards/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/Dawn-Of-The-Cards/favicon-16x16.png><link rel=manifest href=/Dawn-Of-The-Cards/site.webmanifest><link rel=mask-icon href=/Dawn-Of-The-Cards/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><script src=/Dawn-Of-The-Cards/modernizr-simple.js></script>
<link href=/Dawn-Of-The-Cards/article/rendering_a_card/ rel=alternate type=application/rss+xml title="Dawn Of The Cards - Fronkon Games"><link href=/Dawn-Of-The-Cards/article/rendering_a_card/ rel=feed type=application/rss+xml title="Dawn Of The Cards - Fronkon Games"><link rel=canonical href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/rendering_a_card/><link rel=stylesheet href=https://fronkongames.github.io/Dawn-Of-The-Cards/theme.css></head><body class=bilberry-hugo-theme><header style=background-image:url(/Dawn-Of-The-Cards/images/header.png);background-repeat:no-repeat;background-position:50%;width:100%;height:fit-content><div class=container style=height:400px><div class=logo style=margin-top:250px><a href=/Dawn-Of-The-Cards class=logo><img src="https://seccdn.libravatar.org/avatar/23f0a74e9bc0a5eb8500a54f0729e295?d=mm&size=200" alt>
<span class=overlay><i class="fa fa-home"></i></span></a></div></div></header><div class="main container"><div class="article-wrapper u-cf single"><a class=bubble href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/rendering_a_card/><i class="fas fa-fw fa-pencil-alt"></i></a><article class="default article"><div class=content><h1 class=article-title><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/rendering_a_card/>Rendering A Card In URP üñåÔ∏è</a></h1><div class=meta></div><p><img src=/Dawn-Of-The-Cards/images/rendering_a_card/promo.gif alt=Promo title=Promo></p><p>How to make a custom shader to render cards using &lsquo;Universal RP&rsquo; from Unity.</p><blockquote><p>‚ö†Ô∏è <strong>All art in this post have been generated by an AI and do not represent the final style of the game.</strong> ‚ö†Ô∏è</p></blockquote><p>As we saw in the <a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/making_a_3d_card_in_blender/>previous post</a>, each card has three materials:</p><ul><li><strong>FrontFace</strong>: the face where all the important information and the image representing the card will be.</li><li><strong>BackFace</strong>: the face that will be seen when the card is face down.</li><li><strong>Border</strong>: the border material of the card.</li></ul><p>To be able to adjust to the maximum each one of these materials, I will create three custom shaders using the pipeline that the game will use:
&lsquo;<a href=https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/index.html>Universal RP</a>&rsquo;, specifically version 12.1.</p><p>The simplest shader of the three is the one that is in charge of drawing the border of the card, which only has to draw one color:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span>Shader <span style=color:#e6db74>&#34;Card/Border&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Properties are options set per material,</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// exposed by the material inspector.</span>
</span></span><span style=display:flex><span>  Properties
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// [MainColor] allow Material.color to use the correct properties.</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [MainColor]</span> _BaseColor(<span style=color:#e6db74>&#34;Base Color&#34;</span>, Color) = (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Subshaders allow for different behaviour and options for</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// different pipelines and platforms.</span>
</span></span><span style=display:flex><span>  SubShader
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// These tags are shared by all passes in this sub shader.</span>
</span></span><span style=display:flex><span>    Tags { <span style=color:#e6db74>&#34;RenderType&#34;</span> = <span style=color:#e6db74>&#34;Opaque&#34;</span> <span style=color:#e6db74>&#34;Queue&#34;</span> = <span style=color:#e6db74>&#34;Geometry&#34;</span> <span style=color:#e6db74>&#34;RenderPipeline&#34;</span> = <span style=color:#e6db74>&#34;UniversalPipeline&#34;</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Shaders can have several passes which are used to render</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// different data about the material. Each pass has it&#39;s own</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// vertex and fragment function and shader variant keywords.</span>
</span></span><span style=display:flex><span>    Pass
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Begin HLSL code</span>
</span></span><span style=display:flex><span>      HLSLPROGRAM
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Register our programmable stage functions.</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>#pragma vertex vert</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>#pragma fragment frag</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Include basics URP functions.</span>
</span></span><span style=display:flex><span>      <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// This attributes struct receives data about the mesh we&#39;re</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// currently rendering. Data is automatically placed in</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// fields according to their semantic.</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Attributes</span>
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        float4 vertex : POSITION;  <span style=color:#75715e>// Position in object space.</span>
</span></span><span style=display:flex><span>      };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// This struct is output by the vertex function and input to</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// the fragment function. Note that fields will be</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// transformed by the intermediary rasterization stage.</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Varyings</span>
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This value should contain the position in clip space (which</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// is similar to a position on screen) when output from the</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// vertex function. It will be transformed into pixel position</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// of the current fragment on the screen when read from</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// the fragment function.      </span>
</span></span><span style=display:flex><span>        float4 position : SV_POSITION;
</span></span><span style=display:flex><span>      };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      half4 _BaseColor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// The vertex function. This runs for each vertex on the mesh. It</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// must output the position on the screen each vertex should</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// appear at, as well as any data the fragment function will need.</span>
</span></span><span style=display:flex><span>      Varyings vert(Attributes input)
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        Varyings output = (Varyings)<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// These helper functions transform object space values into</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// world and clip space.        </span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> VertexPositionInputs positionInputs = GetVertexPositionInputs(input.vertex.xyz);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Pass position data to the fragment function.</span>
</span></span><span style=display:flex><span>        output.position = positionInputs.positionCS;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// The fragment function. This runs once per fragment, which</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// you can think of as a pixel on the screen. It must output</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// the final color of this pixel.</span>
</span></span><span style=display:flex><span>      half4 frag(<span style=color:#66d9ef>const</span> Varyings input) : SV_Target
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> _BaseColor;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      ENDHLSL
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To check that everything goes well, I will create three materials with the above shader, each one of a color and assign it to each
material on the card.</p><p><img src=/Dawn-Of-The-Cards/images/rendering_a_card/rgb.gif alt=RGB title=RGB></p><p>It looks like everything is correct.</p><p>The next shader in difficulty would be the one for the back face. In it I want to mix two textures, one for the background image and another one as a frame.
The texture of the frame must have a transparent zone (alpha equal to 0) that allows to see the background texture.</p><table><thead><tr><th style=text-align:center>Background</th><th style=text-align:center>Frame</th></tr></thead><tbody><tr><td style=text-align:center><img src=/Dawn-Of-The-Cards/images/rendering_a_card/backface.png alt=Background title=Background></td><td style=text-align:center><img src=/Dawn-Of-The-Cards/images/rendering_a_card/backframe.png alt=Frame title=Frame></td></tr></tbody></table><p>To mix, or more precisely <em>interpolate</em>, both pixels I will use the function <a href=https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-lerp>lerp(x, y, s)</a>, which returns <em>x</em> if <em>s</em> is 0, <em>y</em> if <em>s</em> is 1 and a linearly interpolated value between <em>x</em> and <em>y</em> if the value of <em>s</em> is between 0 and 1.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span>half3 pixel = lerp(image, frame, frame.a);
</span></span></code></pre></div><p>In this way if the transparency of the frame is 0, you will see the image, otherwise you will see the frame. And if it is something in between, we will see a mix between the two images.</p><p><img src=/Dawn-Of-The-Cards/images/rendering_a_card/back.jpg alt=Back title=Back></p><p>This new shader would look like this.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span>Shader <span style=color:#e6db74>&#34;Card/Back Side&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  Properties
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// [MainTexture] allow Material.mainTexture to use</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// the correct properties.</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [MainTexture]</span> _BaseMap(<span style=color:#e6db74>&#34;Image (RGB)&#34;</span>, <span style=color:#ae81ff>2D</span>) = <span style=color:#e6db74>&#34;white&#34;</span> {}
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    _FrameTex(<span style=color:#e6db74>&#34;Frame (RGBA)&#34;</span>, <span style=color:#ae81ff>2D</span>) = <span style=color:#e6db74>&#34;white&#34;</span> {}
</span></span><span style=display:flex><span>    _FrameColor(<span style=color:#e6db74>&#34;Frame Color&#34;</span>, Color) = (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  SubShader
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    Tags { <span style=color:#e6db74>&#34;RenderType&#34;</span> = <span style=color:#e6db74>&#34;Opaque&#34;</span> <span style=color:#e6db74>&#34;Queue&#34;</span> = <span style=color:#e6db74>&#34;Geometry&#34;</span> <span style=color:#e6db74>&#34;RenderPipeline&#34;</span> = <span style=color:#e6db74>&#34;UniversalPipeline&#34;</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Pass
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      HLSLPROGRAM
</span></span><span style=display:flex><span>      <span style=color:#75715e>#pragma vertex vert</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>#pragma fragment frag</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/SurfaceInput.hlsl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Attributes</span>
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        float4 vertex : POSITION;
</span></span><span style=display:flex><span>        float2 uv     : TEXCOORD0; <span style=color:#75715e>// Material texture UVs.</span>
</span></span><span style=display:flex><span>      };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Varyings</span>
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        float4 position : SV_POSITION;
</span></span><span style=display:flex><span>        float2 uv       : TEXCOORD0; <span style=color:#75715e>// Material texture UVs.</span>
</span></span><span style=display:flex><span>      };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// This is automatically set by Unity.</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Used in TRANSFORM_TEX to apply UV tiling.</span>
</span></span><span style=display:flex><span>      float4 _BaseMap_ST;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Defines the Frame texture, sampler and color.</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// _BaseMap is already defined in SurfaceInput.hlsl.</span>
</span></span><span style=display:flex><span>      TEXTURE2D(_FrameTex);
</span></span><span style=display:flex><span>      SAMPLER(sampler_FrameTex);
</span></span><span style=display:flex><span>      float4 _FrameColor;
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>      Varyings vert(Attributes input)
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        Varyings output = (Varyings)<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> VertexPositionInputs positionInputs = GetVertexPositionInputs(input.vertex.xyz);
</span></span><span style=display:flex><span>        output.position = positionInputs.positionCS;
</span></span><span style=display:flex><span>        output.uv = TRANSFORM_TEX(input.uv, _BaseMap);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      half4 frag(Varyings input) : SV_Target
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Sample the textures.</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> half4 image = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, input.uv);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> half4 frame = SAMPLE_TEXTURE2D(_FrameTex, sampler_FrameTex, input.uv) * _FrameColor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Interpolates between image and frame according</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// to the transparency of the frame.</span>
</span></span><span style=display:flex><span>        half4 pixel = lerp(image, frame, frame.a);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> pixel;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      ENDHLSL
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The shader for the front part of the card, in a first version, is similar to the previous one but with another layer. It consists of three layers, that from more to less depth are:</p><ul><li><strong>Background</strong>: the background of the card.</li><li><strong>Image</strong>: the image that represents the card.</li><li><strong>Frame</strong>: the border of the card.</li></ul><table><thead><tr><th style=text-align:center>Background</th><th style=text-align:center>Image</th><th style=text-align:center>Frame</th></tr></thead><tbody><tr><td style=text-align:center><img src=/Dawn-Of-The-Cards/images/rendering_a_card/background.png alt=Background title=Background></td><td style=text-align:center><img src=/Dawn-Of-The-Cards/images/rendering_a_card/image.png alt=Image title=Image></td><td style=text-align:center><img src=/Dawn-Of-The-Cards/images/rendering_a_card/frontframe.png alt=Frame title=Frame></td></tr></tbody></table><p>In addition to defining the new texture, in the &lsquo;frag&rsquo; function you will have to add one more &lsquo;<strong>lerp</strong>&rsquo;:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span>  <span style=color:#75715e>// Sample the textures.</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> half4 image = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, input.uv);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> half4 background = SAMPLE_TEXTURE2D(_BackgroundTex, sampler_BackgroundTex, input.uv);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> half4 frame = SAMPLE_TEXTURE2D(_FrameTex, sampler_FrameTex, input.uv);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Interpolates between image and background according to</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// the transparency of the frame.</span>
</span></span><span style=display:flex><span>  half4 pixel = lerp(background, image, image.a);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// And the result is interpolated with the frame</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// transparency.</span>
</span></span><span style=display:flex><span>  pixel = lerp(pixel, frame, frame.a);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> pixel;
</span></span></code></pre></div><p><img src=/Dawn-Of-The-Cards/images/rendering_a_card/front.jpg alt=Front title=Front></p><p>And why separate the background from the image when they could be a single texture and save a texture fetch? you might be asking yourself.
And you would be right, since a texture fetch (the &lsquo;<strong>SAMPLE_TEXTURE2D</strong>&rsquo; macro) is one of the most expensive operations in shaders.</p><p>The answer is that we can add effects <strong>behind</strong> the image representing the card and <strong>in front</strong> of it.</p><p>The first effect we are going to see is the transformation of the UV coordinates. In particular, the displacement of these, with which we will achieve
the rain effect and the fog effect that you saw at the beginning of this post.</p><p>These effects depend on the type of UV mapping your geometry uses. In my case, as we saw in the <a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/making_a_3d_card_in_blender/>previous post</a>,
I use a cubic projection so if I modify one axis of the coordinates I know that the texture will be displaced on one axis.</p><p>You can do a simple test by creating a cube in a scene and assigning a material to it. You can modify the UV coordinates of the material by changing its &lsquo;<strong>Offset</strong>&rsquo;.</p><p><img src=/Dawn-Of-The-Cards/images/rendering_a_card/uv.gif alt="Offset UV" title="Offset UV"></p><p>I&rsquo;m going to add two more textures to the shader. One between &lsquo;<strong>background</strong>&rsquo; and &lsquo;<strong>image</strong>&rsquo; and another between &lsquo;<strong>image</strong>&rsquo; and &lsquo;<strong>frame</strong>&rsquo;. In total we would have these layers:</p><p><img src=/Dawn-Of-The-Cards/images/rendering_a_card/layers.jpg alt=Layers title=Layers></p><p>It will be in these two new textures where I will apply a displacement in their UV coordinates. We only have to modify the UV coordinates in the macro <strong>SAMPLE_TEXTURE2D</strong>. If &lsquo;<strong>_Offset</strong>&rsquo; were a vector with the offset, it would be applied like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span>float2 newUV = input.uv + _Offset;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> half4 image = SAMPLE_TEXTURE2D(_BackgroundFXTex, sampler_BackgroundFXTex, newUV);
</span></span></code></pre></div><p>But instead of specifying a displacement, I will use a linear velocity vector. I will calculate the final displacement by multiplying this velocity by the time. The time is provided by Unity in the vector &lsquo;<a href=https://docs.unity3d.com/Manual/SL-UnityShaderVariables.html><strong>_Time</strong></a>&rsquo;, its coordinate <strong>y</strong> being the unscaled time. If &lsquo;<strong>_ScrollVelocity</strong>&rsquo; were a vector with the linear velocity, it would be applied like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span>float2 newUV = input.uv + frac(_ScrollVelocity * _Time.y);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> half4 image = SAMPLE_TEXTURE2D(_BackgroundFXTex, sampler_BackgroundFXTex, newUV);
</span></span></code></pre></div><p>As the UV coordinates are between 0 and 1, with the function &lsquo;<a href=https://learn.microsoft.com/windows/win32/direct3dhlsl/dx-graphics-hlsl-frac><strong>frac</strong></a>&rsquo; we will use only the decimal part to add it to these coordinates.</p><p>By using two effect layers, one behind the image and one in front of it, we can give each layer a different speed to simulate depth by making the farthest layer slower.</p><p>To create a rain effect I will use a rain texture that is &lsquo;<strong>seamless</strong>&rsquo;, that is, that you don&rsquo;t notice a cut when you move it. It is important that you use a texture format that allows the transparency channel to have more than one bit of color (not like the PNG format). In my case I used a TGA.</p><p><img src=/Dawn-Of-The-Cards/images/rendering_a_card/rain.png alt=Rain title=Rain></p><p>The final effect would look something like this:</p><p><img src=/Dawn-Of-The-Cards/images/rendering_a_card/valeria.gif alt=Valeria title=Valeria></p><p>By changing the texture to a fog texture, and scrolling on the horizontal axis we can get a fog effect like this:</p><p><img src=/Dawn-Of-The-Cards/images/rendering_a_card/herrick.gif alt=Herrick title=Herrick></p><p>Finally it remains to add something fundamental, text. For this we will use <a href=https://docs.unity3d.com/Manual/com.unity.textmeshpro.html>TextMeshPro</a>, since it provides much better quality and options than the text offered by Unity. To install it just add it using the &lsquo;Package Manager&rsquo;.</p><p><img src=/Dawn-Of-The-Cards/images/rendering_a_card/package.jpg alt=Package title=Package></p><p>I added a child and added a 3D text.</p><p><img src=/Dawn-Of-The-Cards/images/rendering_a_card/tmp.jpg alt=TMP title=TMP></p><p>And adjust the Z coordinate to be slightly ahead of the card.</p><p><img src=/Dawn-Of-The-Cards/images/rendering_a_card/text.jpg alt=Text title=Text></p><p>And <strong>voal√°</strong>!</p><p><img src=/Dawn-Of-The-Cards/images/rendering_a_card/label.jpg alt=Label title=Label></p><p>That&rsquo;s all for now. In next posts I will add other effects that can be useful for a card game. In the meantime you can add some small improvements like:</p><ul><li>One color for each layer to tint it. You would only have to multiply the result of <strong>SAMPLE_TEXTURE2D</strong> by that color.</li><li>Scaling. Simply multiplying by a scalar the UV coordinate.</li><li>Angular velocity, to rotate the layers of the effects.</li><li>Use different <a href=https://photoshoptrainingchannel.com/blending-modes-explained/>blending functions</a> for the effect layers. In this post I have only used a simple way to blend the layers, but there are many blending functions that can give interesting results.</li><li>And&mldr; can you think of anything else? I&rsquo;d love to read about it in the comments.</li></ul><p>Until next time&mldr; <strong>stay gamedev, stay awesome!</strong></p><blockquote><p>‚ö†Ô∏è <strong>In these shaders I have prioritized readability over optimization.</strong> ‚ö†Ô∏è</p><p><a href=https://gist.github.com/FronkonGames/78f2d00334b7aa8d3a3564b6c62f4fe7>üì• BACK SIDE SHADER üì•</a></p><p><a href=https://gist.github.com/FronkonGames/6b419e60eb42d81666bf35f18c59ab00>üì• BORDER SHADER üì•</a></p><p><a href=https://gist.github.com/FronkonGames/c1e4c12b41612f72b84c6ed68076fb49>üì• FRONT SIDE SHADER üì•</a></p></blockquote></div><div class="footer no-tags"></div></article></div><div id=comments-container><script src=https://giscus.app/client.js data-repo=FronkonGames/Dawn-Of-The-Cards data-repo-id=R_kgDOHxLLYA data-category=Devblog data-category-id=DIC_kwDOHxLLYM4CQpcc data-mapping=pathname data-reactions-enabled=1 data-emit-metadata data-theme=preferred_color_scheme data-lang=en crossorigin=anonymous async></script><div id=giscus></div></div></div><footer><div class=container><div class=recent-posts><strong>Latest posts</strong><ul><li><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/unity_is_a_harsh_mistress/>Unity is a harsh mistress üíî</a></li><li><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/dragging_and_dropping_3d_cards/>Dragging And Dropping 3D Cards üÉè</a></li><li><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/rendering_a_card/>Rendering A Card In URP üñåÔ∏è</a></li><li><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/making_a_3d_card_in_blender/>Making A 3D Card In Blender üÉè</a></li><li><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/hello_everybody/>Hello Everybody! üßü</a></li><li><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/archive/>Archive page</a></li></ul></div><div class=right><div class=external-profiles><strong>Social media</strong>
<a href=https://twitter.com/fronkongames target=_blank><i class="fab fa-twitter"></i></a>
<a href=https://github.com/FronkonGames target=_blank><i class="fab fa-github"></i></a></div></div></div></footer><div class=credits><div class=container><div class=copyright><a href=https://fronkongames.github.io/ target=_blank>&copy;
2023
by Fronkon Games</a></div><div class=author><a href=https://github.com/Lednerb/bilberry-hugo-theme target=_blank>Bilberry Hugo Theme</a></div></div></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-7SGJ6HWLSZ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7SGJ6HWLSZ",{anonymize_ip:!1})}</script><script src=https://fronkongames.github.io/Dawn-Of-The-Cards/theme.js></script><div id=activate-algolia-search class=hidden><input type=hidden id=algolia-search-appId value=45CEN6X6AT>
<input type=hidden id=algolia-search-apiKey value=16030625f1a4d0dd3b8aefd794fd4cf1>
<input type=hidden id=algolia-search-indexName value=bilberry-hugo-theme>
<input type=hidden id=algolia-search-noSearchResults value="Nothing found.">
<input type=hidden id=algolia-search-currentLanguageOnly></div></body></html>