<!doctype html><html itemscope itemtype=https://schema.org/WebPage class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=siteBaseUrl content="https://fronkongames.github.io/Dawn-Of-The-Cards/"><meta name=author content="Martin Bustos"><meta name=description content="A devblog about the development of 'Dawn Of The Cards'."><meta name=keywords content="devblog,blog,gamedev,gamedevelopment,indiedev,unity,unity3d,roguelike,deckbuilding,zombie,zombies,dawn,cards"><meta name=generator content="Hugo 0.104.2"><title>Rendering A Card In URP üñåÔ∏è | Dawn Of The Cards - Fronkon Games</title><meta itemprop=name content="Rendering A Card In URP üñåÔ∏è"><meta itemprop=description content="Rendering A Card In URP üñåÔ∏è - A devblog about the development of 'Dawn Of The Cards'."><meta property="og:title" content="Rendering A Card In URP üñåÔ∏è"><meta property="og:description" content="Rendering A Card In URP üñåÔ∏è - A devblog about the development of 'Dawn Of The Cards'."><meta property="og:image" content="https://www.gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e?size=200"><meta property="og:url" content="https://fronkongames.github.io/Dawn-Of-The-Cards/article/rendering_a_card/"><meta property="og:site_name" content="Dawn Of The Cards - Fronkon Games"><meta property="og:type" content="article"><link rel=apple-touch-icon sizes=152x152 href=/Dawn-Of-The-Cards/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/Dawn-Of-The-Cards/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/Dawn-Of-The-Cards/favicon-16x16.png><link rel=manifest href=/Dawn-Of-The-Cards/site.webmanifest><link rel=mask-icon href=/Dawn-Of-The-Cards/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><script src=/Dawn-Of-The-Cards/modernizr-simple.js></script>
<link href=/Dawn-Of-The-Cards/article/rendering_a_card/ rel=alternate type=application/rss+xml title="Dawn Of The Cards - Fronkon Games"><link href=/Dawn-Of-The-Cards/article/rendering_a_card/ rel=feed type=application/rss+xml title="Dawn Of The Cards - Fronkon Games"><link rel=canonical href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/rendering_a_card/><link rel=stylesheet href=https://fronkongames.github.io/Dawn-Of-The-Cards/theme.css></head><body class=bilberry-hugo-theme><header style=background-image:url(/Dawn-Of-The-Cards/images/header.png);background-repeat:no-repeat;background-position:50%;width:100%;height:fit-content><div class=container style=height:400px><div class=logo style=margin-top:250px><a href=/Dawn-Of-The-Cards class=logo><img src="https://seccdn.libravatar.org/avatar/23f0a74e9bc0a5eb8500a54f0729e295?d=mm&size=200" alt>
<span class=overlay><i class="fa fa-home"></i></span></a></div></div></header><div class="main container"><div class="article-wrapper u-cf single"><a class=bubble href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/rendering_a_card/><i class="fas fa-fw fa-pencil-alt"></i></a><article class="default article"><div class=content><h1 class=article-title><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/rendering_a_card/>Rendering A Card In URP üñåÔ∏è</a></h1><div class=meta></div><p><img src=/Dawn-Of-The-Cards/images/rendering_a_card/promo.gif alt=Promo title=Promo></p><p>How to make a custom shader to render cards using &lsquo;Universal RP&rsquo; from Unity.</p><blockquote><p>‚ö†Ô∏è <strong>All art in this post have been generated by an AI and do not represent the final style of the game.</strong> ‚ö†Ô∏è</p></blockquote><p>As we saw in the <a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/making_a_3d_card_in_blender/>previous post</a>, each card has three materials:</p><ul><li><strong>FrontFace</strong>: the face where all the important information and the image representing the card will be.</li><li><strong>BackFace</strong>: the face that will be seen when the card is face down.</li><li><strong>Border</strong>: the border material of the card.</li></ul><p>To be able to adjust to the maximum each one of these materials, I will create three custom shaders using the pipeline that the game will use:
&lsquo;<a href=https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/index.html>Universal RP</a>&rsquo;, specifically version 12.1.</p><p>The simplest shader of the three is the one that is in charge of drawing the border of the card, which only has to draw one color:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span>Shader <span style=color:#e6db74>&#34;Card/Border&#34;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Properties are options set per material,</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// exposed by the material inspector.</span>
</span></span><span style=display:flex><span>  Properties
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [MainColor]</span> _BaseColor(<span style=color:#e6db74>&#34;Base Color&#34;</span>, Color) = (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Subshaders allow for different behaviour and options for</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// different pipelines and platforms.</span>
</span></span><span style=display:flex><span>  SubShader
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// These tags are shared by all passes in this sub shader.</span>
</span></span><span style=display:flex><span>    Tags { <span style=color:#e6db74>&#34;RenderType&#34;</span> = <span style=color:#e6db74>&#34;Opaque&#34;</span> <span style=color:#e6db74>&#34;Queue&#34;</span> = <span style=color:#e6db74>&#34;Geometry&#34;</span> <span style=color:#e6db74>&#34;RenderPipeline&#34;</span> = <span style=color:#e6db74>&#34;UniversalPipeline&#34;</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Shaders can have several passes which are used to render</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// different data about the material. Each pass has it&#39;s own</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// vertex and fragment function and shader variant keywords.</span>
</span></span><span style=display:flex><span>    Pass
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Begin HLSL code</span>
</span></span><span style=display:flex><span>      HLSLPROGRAM
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Register our programmable stage functions.</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>#pragma vertex vert</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>#pragma fragment frag</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Include basics URP functions.</span>
</span></span><span style=display:flex><span>      <span style=color:#960050;background-color:#1e0010>#</span>include <span style=color:#e6db74>&#34;Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// This attributes struct receives data about the mesh we&#39;re</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// currently rendering. Data is automatically placed in</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// fields according to their semantic.</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Attributes</span>
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        float4 vertex : POSITION;  <span style=color:#75715e>// Position in object space.</span>
</span></span><span style=display:flex><span>      };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// This struct is output by the vertex function and input to</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// the fragment function. Note that fields will be</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// transformed by the intermediary rasterization stage.</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Varyings</span>
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This value should contain the position in clip space (which</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// is similar to a position on screen) when output from the</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// vertex function. It will be transformed into pixel position</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// of the current fragment on the screen when read from</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// the fragment function.      </span>
</span></span><span style=display:flex><span>        float4 position : SV_POSITION;
</span></span><span style=display:flex><span>      };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      half4 _BaseColor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// The vertex function. This runs for each vertex on the mesh. It</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// must output the position on the screen each vertex should</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// appear at, as well as any data the fragment function will need.</span>
</span></span><span style=display:flex><span>      Varyings vert(Attributes input)
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        Varyings output = (Varyings)<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// These helper functions transform object space values into</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// world and clip space.        </span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> VertexPositionInputs positionInputs = GetVertexPositionInputs(input.vertex.xyz);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Pass position data to the fragment function.</span>
</span></span><span style=display:flex><span>        output.position = positionInputs.positionCS;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> output;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// The fragment function. This runs once per fragment, which</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// you can think of as a pixel on the screen. It must output</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// the final color of this pixel.</span>
</span></span><span style=display:flex><span>      half4 frag(<span style=color:#66d9ef>const</span> Varyings input) : SV_Target
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> _BaseColor;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      ENDHLSL
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To check that everything goes well, I will create three materials with the above shader, each one of a color and assign it to each
material on the card.</p><p><img src=/Dawn-Of-The-Cards/images/rendering_a_card/rgb.gif alt=RGB title=RGB></p><p>It looks like everything is correct.</p><p>The next shader in difficulty would be the one for the back face. In it I want to mix two textures, one for the background and another one as a frame.
The texture of the frame must have a transparent zone (alpha equal to 0) that allows to see the background texture.</p><table><thead><tr><th style=text-align:center>Background</th><th style=text-align:center>Frame</th></tr></thead><tbody><tr><td style=text-align:center><img src=/Dawn-Of-The-Cards/images/rendering_a_card/backface.png alt=Background title=Background></td><td style=text-align:center><img src=/Dawn-Of-The-Cards/images/rendering_a_card/backframe.png alt=Frame title=Frame></td></tr></tbody></table><p>To mix, or more precisely <em>interpolate</em>, both pixels I will use the function <a href=https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-lerp>lerp(x, y, s)</a>, which returns <em>x</em> if <em>s</em> is 0, <em>y</em> if <em>s</em> is 1 and a linearly interpolated value between <em>x</em> and <em>y</em> if the value of <em>s</em> is between 0 and 1.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span>half3 pixel = lerp(image, frame, frame.a);
</span></span></code></pre></div><p>In this way if the transparency of the frame is 0, you will see the image, otherwise you will see the frame.</p><p><img src=/Dawn-Of-The-Cards/images/rendering_a_card/back.jpg alt=Back title=Back></p><blockquote><p>TODO</p></blockquote><p>Until next time&mldr; <strong>stay gamedev, stay awesome!</strong></p></div><div class="footer no-tags"></div></article></div><div id=comments-container><script src=https://giscus.app/client.js data-repo=FronkonGames/Dawn-Of-The-Cards data-repo-id=R_kgDOHxLLYA data-category=Devblog data-category-id=DIC_kwDOHxLLYM4CQpcc data-mapping=pathname data-reactions-enabled=1 data-emit-metadata data-theme=preferred_color_scheme data-lang=en crossorigin=anonymous async></script><div id=giscus></div></div></div><footer><div class=container><div class=recent-posts><strong>Latest posts</strong><ul><li><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/rendering_a_card/>Rendering A Card In URP üñåÔ∏è</a></li><li><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/making_a_3d_card_in_blender/>Making A 3D Card In Blender üÉè</a></li><li><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/hello_everybody/>Hello Everybody! üßü</a></li><li><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/archive/>Archive page</a></li></ul></div><div class=right><div class=external-profiles><strong>Social media</strong>
<a href=https://twitter.com/fronkongames target=_blank><i class="fab fa-twitter"></i></a>
<a href=https://github.com/FronkonGames target=_blank><i class="fab fa-github"></i></a></div></div></div></footer><div class=credits><div class=container><div class=copyright><a href=https://fronkongames.github.io/ target=_blank>&copy;
2022
by Fronkon Games</a></div><div class=author><a href=https://github.com/Lednerb/bilberry-hugo-theme target=_blank>Bilberry Hugo Theme</a></div></div></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-7SGJ6HWLSZ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7SGJ6HWLSZ",{anonymize_ip:!1})}</script><script src=https://fronkongames.github.io/Dawn-Of-The-Cards/theme.js></script><div id=activate-algolia-search class=hidden><input type=hidden id=algolia-search-appId value=45CEN6X6AT>
<input type=hidden id=algolia-search-apiKey value=16030625f1a4d0dd3b8aefd794fd4cf1>
<input type=hidden id=algolia-search-indexName value=bilberry-hugo-theme>
<input type=hidden id=algolia-search-noSearchResults value="Nothing found.">
<input type=hidden id=algolia-search-currentLanguageOnly></div></body></html>