<!doctype html><html itemscope itemtype=https://schema.org/WebPage class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=siteBaseUrl content="https://fronkongames.github.io/Dawn-Of-The-Cards/"><meta name=author content="Martin Bustos"><meta name=description content="A devblog about the development of 'Dawn Of The Cards'."><meta name=keywords content="devblog,blog,gamedev,gamedevelopment,indiedev,unity,unity3d,roguelike,deckbuilding,zombie,zombies,dawn,cards"><meta name=generator content="Hugo 0.118.2"><title>Dragging And Dropping 3D Cards üÉè | Dawn Of The Cards - Fronkon Games</title><meta itemprop=name content="Dragging And Dropping 3D Cards üÉè"><meta itemprop=description content="Dragging And Dropping 3D Cards üÉè - A devblog about the development of 'Dawn Of The Cards'."><meta property="og:title" content="Dragging And Dropping 3D Cards üÉè"><meta property="og:description" content="Dragging And Dropping 3D Cards üÉè - A devblog about the development of 'Dawn Of The Cards'."><meta property="og:image" content="https://www.gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e?size=200"><meta property="og:url" content="https://fronkongames.github.io/Dawn-Of-The-Cards/article/dragging_and_dropping_3d_cards/"><meta property="og:site_name" content="Dawn Of The Cards - Fronkon Games"><meta property="og:type" content="article"><link rel=apple-touch-icon sizes=152x152 href=/Dawn-Of-The-Cards/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/Dawn-Of-The-Cards/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/Dawn-Of-The-Cards/favicon-16x16.png><link rel=manifest href=/Dawn-Of-The-Cards/site.webmanifest><link rel=mask-icon href=/Dawn-Of-The-Cards/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><script src=/Dawn-Of-The-Cards/modernizr-simple.js></script>
<link href=/Dawn-Of-The-Cards/article/dragging_and_dropping_3d_cards/ rel=alternate type=application/rss+xml title="Dawn Of The Cards - Fronkon Games"><link href=/Dawn-Of-The-Cards/article/dragging_and_dropping_3d_cards/ rel=feed type=application/rss+xml title="Dawn Of The Cards - Fronkon Games"><link rel=canonical href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/dragging_and_dropping_3d_cards/><link rel=stylesheet href=https://fronkongames.github.io/Dawn-Of-The-Cards/theme.css></head><body class=bilberry-hugo-theme><header style=background-image:url(/Dawn-Of-The-Cards/images/header.png);background-repeat:no-repeat;background-position:50%;width:100%;height:fit-content><div class=container style=height:400px><div class=logo style=margin-top:250px><a href=/Dawn-Of-The-Cards class=logo><img src="https://seccdn.libravatar.org/avatar/23f0a74e9bc0a5eb8500a54f0729e295?d=mm&size=200" alt>
<span class=overlay><i class="fa fa-home"></i></span></a></div></div></header><div class="main container"><div class="article-wrapper u-cf single"><a class=bubble href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/dragging_and_dropping_3d_cards/><i class="fas fa-fw fa-pencil-alt"></i></a><article class="default article"><div class=content><h1 class=article-title><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/dragging_and_dropping_3d_cards/>Dragging And Dropping 3D Cards üÉè</a></h1><div class=meta></div><p><img src=/Dawn-Of-The-Cards/images/dragging_and_dropping_3d_cards/promo.gif alt=Promo title=Promo></p><p>Moving cards, with juice.</p><p>Now that I have defined <a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/rendering_a_card/>visually a card</a>, the next thing to do is to move it around the scene.</p><p>To do this we first have to detect the cards. We will do this using the &lsquo;<strong>Raycast</strong>&rsquo; functions, which <strong>fire</strong> rays that when colliding with an object give us information about it.</p><p>Since it is a performance consuming operation, we will use some tricks to optimize it. The first one is that we will create a <a href=https://docs.unity3d.com/Manual/use-layers.html>layer</a> to discard objects that are not involved in the operation. We will named it &lsquo;<strong>DragAndDrop</strong>&rsquo;.</p><p><img src=/Dawn-Of-The-Cards/images/dragging_and_dropping_3d_cards/layers.jpg alt=Layers title=Layers></p><p>We will also limit the ray length to the maximum distance our camera sees, since as a general rule we are not interested in objects we are not going to see. This distance is &lsquo;<strong>Camera.main.farClipPlane</strong>&rsquo;.</p><p>Since the &lsquo;<strong>Raycast</strong>&rsquo; operation is going to be used inside the &lsquo;<strong>Update</strong>&rsquo; loop (it is going to be executed every frame), it is always a good idea to avoid allocating memory if we can avoid it. So we will create a <a href=https://docs.unity3d.com/ScriptReference/Ray.html>Ray</a> and use the function <a href=https://docs.unity3d.com/ScriptReference/Physics.RaycastNonAlloc.html>Physics.RaycastNonAlloc</a>.</p><p>The code to detect the cards would look something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span>  <span style=color:#75715e>// Layer of the objects to be detected.</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>  [SerializeField]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> LayerMask raycastMask;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// How many impacts of the beam we want to obtain.</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> HitsCount = <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Information on the impacts of shooting a ray.</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> RaycastHit[] raycastHits = <span style=color:#66d9ef>new</span> RaycastHit[HitsCount];
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Ray created from the camera to the projection of the mouse</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// coordinates on the scene.</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> Ray mouseRay;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// Returns the Transfrom of the object closest to the origin</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// of the ray.</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;returns&gt;Transform or null if there is no impact.&lt;/returns&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> Transform MouseRaycast()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    Transform hit = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Fire the ray!</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Physics.RaycastNonAlloc(mouseRay,
</span></span><span style=display:flex><span>                                raycastHits,
</span></span><span style=display:flex><span>                                Camera.main.farClipPlane,
</span></span><span style=display:flex><span>                                raycastMask) &gt; <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// We order the impacts according to distance.</span>
</span></span><span style=display:flex><span>      System.Array.Sort(raycastHits,
</span></span><span style=display:flex><span>                        (x, y) =&gt; x.distance.CompareTo(y.distance));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// We are only interested in the first one.</span>
</span></span><span style=display:flex><span>      hit = raycastHits[<span style=color:#ae81ff>0</span>].transform;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> hit;
</span></span><span style=display:flex><span>  }  
</span></span></code></pre></div><p>Before calling this function, we must update &lsquo;<strong>mouseRay</strong>&rsquo; with the mouse coordinates. We will do it with this code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span>  mouseRay = Camera.main.ScreenPointToRay(Input.mousePosition);
</span></span></code></pre></div><blockquote><p>‚ö†Ô∏è <strong>In this post I will use the old <a href=https://docs.unity3d.com/ScriptReference/Input.html>Input</a> for simplicity, but it is recommended to use the new <a href=https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/QuickStartGuide.html>Input System</a>.</strong> ‚ö†Ô∏è</p></blockquote><p>In order to get all this to work on a card, we must first add a &lsquo;<a href=https://docs.unity3d.com/ScriptReference/Collider.html>Collider</a>&rsquo;. Without this component, our ray would pass through the card without detecting it. A &lsquo;<a href=https://docs.unity3d.com/Manual/class-BoxCollider.html>Box Collider</a>&rsquo; is a good choice for the type of geometry of a card, but if you need more precision you can use a &lsquo;<a href=https://docs.unity3d.com/Manual/class-MeshCollider.html>Mesh Collider</a>&rsquo;.</p><p>The second thing to do is to assign the &lsquo;<strong>layer</strong>&rsquo; we have selected to the chart. We are now ready to detect a card.</p><p><img src=/Dawn-Of-The-Cards/images/dragging_and_dropping_3d_cards/rayhit.gif alt="Ray hit" title="Ray Hit"></p><p>Now we can start moving our cards. First we are going to define two interfaces, the first one is <strong>IDrag</strong>, for objects that you can drag.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// Draggable object.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IDrag</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt; Can it be draggable? &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsDraggable { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt; A Drag operation is currently underway. &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> Dragging { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt; Mouse enters the object. &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;position&#34;&gt;Mouse position.&lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnPointerEnter(Vector3 position);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt; Mouse exits object. &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;position&#34;&gt;Mouse position.&lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnPointerExit(Vector3 position);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt; Drag begins. &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;position&#34;&gt;Mouse position.&lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnBeginDrag(Vector3 position);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt;A drag is being made. &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;deltaPosition&#34;&gt; Mouse offset position. &lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;droppable&#34;&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// Object on which a drop may be made, or null. &lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnDrag(Vector3 deltaPosition, IDrop droppable);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt; The drag operation is completed. &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;position&#34;&gt;Mouse position.&lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;droppable&#34;&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// Object on which a drop may be made, or null. &lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnEndDrag(Vector3 position, IDrop droppable);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And the second is <strong>IDrop</strong>, for objects that can accept IDrag objects.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// Accept draggable objects.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IDrop</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt; Is it droppable? &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsDroppable { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt; Accept an IDrag? &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;drag&#34;&gt;Object IDrag.&lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;returns&gt;Accept or not the object.&lt;/returns&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> AcceptDrop(IDrag drag);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt; Performs the drop operation of an IDrag object. &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;drag&#34;&gt;Object IDrag.&lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnDrop(IDrag drag);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As you can see, it is <strong>IDrop</strong> that will authorize an <strong>IDrag</strong>, with its <strong>AcceptDrop</strong> method, whether or not to accept a drop operation to be executed on it.</p><p>With these two interfaces ready we can start with the one in charge of handling the drag and drop operations of our cards. We can call it &lsquo;<strong>DragAndDropManager</strong>&rsquo; and will be a <a href=https://docs.unity3d.com/ScriptReference/MonoBehaviour.html>MonoBehaviour</a>. An operation of drag & drop operation can be divided into:</p><ol><li>There is no drag operation at present.</li></ol><ul><li>Cards must be detected under the mouse pointer.<ul><li>If a card is detected and the left mouse button is pressed, a drag operation is started and the <strong>OnBeginDrag</strong> method must be called.</li><li>If there is a detected card and no button is being pressed, the <strong>OnPointerEnter</strong> and <strong>OnPointerExit</strong> methods of the detected card are called.</li></ul></li></ul><ol start=2><li>A drag operation is in progress.</li></ol><ul><li>If the left mouse button is pressed, the card should be moved and the <strong>OnDrag</strong> method should be called.</li><li>If it is not, the drag operation must be finished and the <strong>OnEndDrag</strong> method must be called.</li></ul><blockquote><p>‚ö†Ô∏è <strong>All the code in this article is designed to move the cards in the XZ plane and use the Y axis for the height. If you use different axes you will have to modify the code.</strong> ‚ö†Ô∏è</p></blockquote><p>All this will have to be done in each frame, so it will be done inside the function &lsquo;<strong>Update</strong>&rsquo; of &lsquo;<strong>DragAndDropManager</strong>&rsquo;. We will use these variables:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>// Height at which we want the card to be in a drag operation.</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[SerializeField, Range(0.0f, 10.0f)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>float</span> height = <span style=color:#ae81ff>1.0f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Object to which we are doing a drag operation</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// or null if no drag operation currently exists.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> IDrag currentDrag;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// IDrag objects that the mouse passes over.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> IDrag possibleDrag;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// To know the position of the drag object.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> Transform currentDragTransform;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// To calculate the mouse offset (in world-space).</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> Vector3 oldMouseWorldPosition;
</span></span></code></pre></div><p>Let&rsquo;s see how to detect an <strong>IDrag</strong>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;Detects an IDrag object under the mouse.&lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;returns&gt;IDrag or null.&lt;/returns&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> IDrag DetectDraggable()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  IDrag draggable = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  mouseRay = Camera.main.ScreenPointToRay(Input.mousePosition);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Transform hit = MouseRaycast();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (hit != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    draggable = hit.GetComponent&lt;IDrag&gt;();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (draggable <span style=color:#66d9ef>is</span> { IsDraggable: <span style=color:#66d9ef>true</span> })
</span></span><span style=display:flex><span>      currentDragTransform = hit;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      draggable = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> draggable;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now there are two possibilities, that the left mouse button is pressed or not pressed. If it is pressed and there is an <strong>IDrag</strong> object under the mouse pointer:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span>IDrag draggable = DetectDraggable();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Left mouse button pressed?</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (Input.GetMouseButtonDown(<span style=color:#ae81ff>0</span>) == <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Is there an IDrag object under the mouse pointer?</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (draggable != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We already have an object to start the drag operation!</span>
</span></span><span style=display:flex><span>    currentDrag = draggable;
</span></span><span style=display:flex><span>    currentDragTransform = hit;
</span></span><span style=display:flex><span>    oldMouseWorldPosition = MousePositionToWorldPoint();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Hide the mouse icon.</span>
</span></span><span style=display:flex><span>    Cursor.visible = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// And we lock the movements to the window frame,</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// so we can&#39;t move objects out of the camera&#39;s view.</span>
</span></span><span style=display:flex><span>    Cursor.lockState = CursorLockMode.Confined;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The drag operation begins.</span>
</span></span><span style=display:flex><span>    currentDrag.Dragging = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    currentDrag.OnBeginDrag(<span style=color:#66d9ef>new</span> Vector3(raycastHits[<span style=color:#ae81ff>0</span>].point.x,
</span></span><span style=display:flex><span>                                        raycastHits[<span style=color:#ae81ff>0</span>].point.y + height,
</span></span><span style=display:flex><span>                                        raycastHits[<span style=color:#ae81ff>0</span>].point.z));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And if the left mouse button is not pressed:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>// Left mouse button not pressed?</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (Input.GetMouseButtonDown(<span style=color:#ae81ff>0</span>) == <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>// We pass over a new IDrag?</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (draggable != <span style=color:#66d9ef>null</span> &amp;&amp; possibleDrag == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We execute its OnPointerEnter.</span>
</span></span><span style=display:flex><span>    possibleDrag = draggable;
</span></span><span style=display:flex><span>    possibleDrag.OnPointerEnter(raycastHits[<span style=color:#ae81ff>0</span>].point);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// We are leaving an IDrag?</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (draggable == <span style=color:#66d9ef>null</span> &amp;&amp; possibleDrag != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We execute its OnPointerExit.</span>
</span></span><span style=display:flex><span>    possibleDrag.OnPointerExit(raycastHits[<span style=color:#ae81ff>0</span>].point);
</span></span><span style=display:flex><span>    possibleDrag = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We already have the first part, now let&rsquo;s go for the second part: to handle a drag operation. The first thing we will do is a new method that will return the <strong>IDrop</strong> that is under a card. It&rsquo;s not as simple as &lsquo;<strong>DetectDraggable()</strong>&rsquo;, since a card has a surface and can be on several objects at once. We will need to cast four rays, one for each corner. And to choose one, we will order the
hits by proximity to the center of the card, this way we will get the <strong>IDrop</strong> object that is on the card and is the closest to it.</p><p>We will store the rays hits in an array:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>// Information on impacts from the corners of a card.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> RaycastHit[] cardHits = <span style=color:#66d9ef>new</span> RaycastHit[<span style=color:#ae81ff>4</span>];
</span></span></code></pre></div><p>And this is the method to search for the nearest IDrop:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;Detects an IDrop object under the mouse.&lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;returns&gt;IDrop or null.&lt;/returns&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> IDrop DetectDroppable()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  IDrop droppable = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// The four corners of the card.</span>
</span></span><span style=display:flex><span>  Vector3 position = currentDragTransform.position;
</span></span><span style=display:flex><span>  Vector2 halfSize = cardSize * <span style=color:#ae81ff>0.5f</span>;
</span></span><span style=display:flex><span>  Vector3[] cardConner =
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span>(position.x + halfSize.x, position.y, position.z - halfSize.y),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span>(position.x + halfSize.x, position.y, position.z + halfSize.y),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span>(position.x - halfSize.x, position.y, position.z - halfSize.y),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span>(position.x - halfSize.x, position.y, position.z + halfSize.y)
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> cardHitIndex = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  cardHits.Clear();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// We launch the four rays.</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; cardConner.Length; ++i)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    Ray ray = <span style=color:#66d9ef>new</span>(cardConner[i], Vector3.down);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Physics.RaycastNonAlloc(ray,
</span></span><span style=display:flex><span>                                raycastHits,
</span></span><span style=display:flex><span>                                Camera.main.farClipPlane,
</span></span><span style=display:flex><span>                                raycastMask) &gt; <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// We order the impacts by distance from the origin of the ray.</span>
</span></span><span style=display:flex><span>      System.Array.Sort(raycastHits, (x, y) =&gt;
</span></span><span style=display:flex><span>        x.distance.CompareTo(y.distance));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// We are only interested in the closest one.</span>
</span></span><span style=display:flex><span>      cardHits[cardHitIndex++] = raycastHits[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (cardHitIndex &gt; <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We are looking for the nearest possible IDrop.</span>
</span></span><span style=display:flex><span>    System.Array.Sort(cardHits, (x, y) =&gt;
</span></span><span style=display:flex><span>      x.distance.CompareTo(y.distance));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    droppable = cardHits[<span style=color:#ae81ff>0</span>].transform.GetComponent&lt;IDrop&gt;();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> droppable;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s see it in action:</p><p><img src=/Dawn-Of-The-Cards/images/dragging_and_dropping_3d_cards/cardhits.gif alt="Card hits" title="Card Hits"></p><p>We can now proceed to the part where we handle a drag operation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#66d9ef>if</span> (currentDrag != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  IDrop droppable = DetectDroppable();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Is the left mouse button held down?</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (Input.GetMouseButton(<span style=color:#ae81ff>0</span>) == <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Calculate the offset of the mouse with respect</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// to its previous position.</span>
</span></span><span style=display:flex><span>    Vector3 mouseWorldPosition = MousePositionToWorldPoint();
</span></span><span style=display:flex><span>    Vector3 offset = mouseWorldPosition - oldMouseWorldPosition;
</span></span><span style=display:flex><span>    offset *= dragSpeed;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// OnDrag is executed.</span>
</span></span><span style=display:flex><span>    currentDrag.OnDrag(offset, droppable);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    oldMouseWorldPosition = mouseWorldPosition;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (Input.GetMouseButtonUp(<span style=color:#ae81ff>0</span>) == <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The left mouse button is released and</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// the drag operation is finished.</span>
</span></span><span style=display:flex><span>    currentDrag.Dragging = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    currentDrag.OnEndDrag(raycastHits[<span style=color:#ae81ff>0</span>].point, droppable);
</span></span><span style=display:flex><span>    currentDrag = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    currentDragTransform = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We return the mouse icon to its normal state.</span>
</span></span><span style=display:flex><span>    Cursor.visible = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    Cursor.lockState = CursorLockMode.None;
</span></span><span style=display:flex><span>  }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We already have the complete manager, but if you look at the code it doesn&rsquo;t actually move anything. That&rsquo;s because it&rsquo;s the <strong>IDrag</strong> objects that are responsible for doing it. Let&rsquo;s see how they would be an object <strong>IDrag</strong>, which in our case is a card.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// Card Drag.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[RequireComponent(typeof(Collider))]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CardDrag</span> : MonoBehaviour, IDrag
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsDraggable { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>set</span>; } = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> Dragging { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Position when the Drag starts.</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> Vector3 dragOriginPosition;  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Unused for the moment.</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnPointerEnter(Vector3 position) { }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnPointerExit(Vector3 position)  { }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt; Drag begins. &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;position&#34;&gt;Mouse position.&lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnBeginDrag(Vector3 position)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We store the current position, so that in case</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// the drag operation is not completed, the card</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// will return to its original position.</span>
</span></span><span style=display:flex><span>    dragOriginPosition = transform.position;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We raise the card to the height indicated by &#39;position&#39;.</span>
</span></span><span style=display:flex><span>    transform.position = <span style=color:#66d9ef>new</span> Vector3(transform.position.x,
</span></span><span style=display:flex><span>                                     position.y,
</span></span><span style=display:flex><span>                                     transform.position.z);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt;A drag is being made. &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;deltaPosition&#34;&gt; Mouse offset position. &lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;droppable&#34;&gt;Object on which a drop may be made, or null.&lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnDrag(Vector3 deltaPosition, IDrop droppable)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We ignore the displacement of the height.</span>
</span></span><span style=display:flex><span>    deltaPosition.y = <span style=color:#ae81ff>0.0f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We move the card.</span>
</span></span><span style=display:flex><span>    transform.position += deltaPosition;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt; The drag operation is completed. &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;position&#34;&gt;Mouse position.&lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;droppable&#34;&gt;Object on which a drop may be made, or null.&lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnEndDrag(Vector3 position, IDrop droppable)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The IDrop object is active and accepts IDrag.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (droppable <span style=color:#66d9ef>is</span> { IsDroppable: <span style=color:#66d9ef>true</span> } &amp;&amp;
</span></span><span style=display:flex><span>        droppable.AcceptDrop(<span style=color:#66d9ef>this</span>) == <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>      transform.position = <span style=color:#66d9ef>new</span> Vector3(transform.position.x,
</span></span><span style=display:flex><span>                                       position.y,
</span></span><span style=display:flex><span>                                       transform.position.z);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// There was no drop, we return to the original position.</span>
</span></span><span style=display:flex><span>      transform.position = dragOriginPosition;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>Remember that I am moving cards that do not have physics. In the case of objects with physics (with the <a href=https://docs.unity3d.com/es/2019.4/Manual/class-Rigidbody.html>RigidBody</a> component), the correct way to move them is using &lsquo;<a href=https://docs.unity3d.com/ScriptReference/Rigidbody.MovePosition.html>RigidBody.MovePosition</a>&rsquo; if it is <a href=https://docs.unity3d.com/ScriptReference/Rigidbody-isKinematic.html>Kinematic</a>, or using &lsquo;<a href=https://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html>RigidBody.AddForce</a>&rsquo; if it is not.</p></blockquote><p>We also need an <strong>IDrop</strong> object that will accept our traveling card. It is as simple as this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// Accept draggable objects.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DroppableFloor</span> : MonoBehaviour, IDrop
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsDroppable =&gt; <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// We accept all IDrags.</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> AcceptDrop(IDrag drag) =&gt; <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnDrop(IDrag drag) { }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s take a look at a successful drag operation.</p><p><img src=/Dawn-Of-The-Cards/images/dragging_and_dropping_3d_cards/dragok.gif alt="Drag Ok" title="Drag Ok"></p><p>And now one that does not, since one of the corners collides with an <strong>IDrag</strong> (another card) and this one is closer to the <strong>IDrop</strong> (the ground).</p><p><img src=/Dawn-Of-The-Cards/images/dragging_and_dropping_3d_cards/dragfail.gif alt="Drag Fail" title="Drag Fail"></p><p>We already have the basics. Now let&rsquo;s improve it a bit. The first thing we can do is change the way we pick up and drop the cards. Now they do it instantly,
they <strong>teleport</strong> to the position we tell them to. Instead we can use the velocity formula (velocity = space / time) to move with constant velocity the cards.
We would have something like this:</p><p><img src=/Dawn-Of-The-Cards/images/dragging_and_dropping_3d_cards/draglinear.gif alt="Drag Linear" title="Drag Linear"></p><p>Better, but still doesn&rsquo;t give a good feeling. Objects in real life do not reach a speed at instance, they have <a href=https://en.wikipedia.org/wiki/Inertia>inertia</a>. To make it similar in a simple way
we can use <a href=https://easings.net/>Easing functions</a>, functions that interpolate values (values, vectors, colors, etc) using different curves.</p><p><img src=/Dawn-Of-The-Cards/images/dragging_and_dropping_3d_cards/easings.gif alt=Easings title=Easings></p><p>There are many libraries with these functions. You may be interested in using my &lsquo;<a href=https://gist.github.com/FronkonGames/ae3d0d613ac4ea6738e288c0a490c020>Tiny Tween</a>&rsquo;, a simple to use library, very complete and in <strong>one file</strong>.</p><p>Let&rsquo;s change the way we pick up cards, using &lsquo;<a href=https://gist.github.com/FronkonGames/ae3d0d613ac4ea6738e288c0a490c020>Tiny Tween</a>&rsquo; to raise it to the height we want in a natural way.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnBeginDrag(Vector3 position)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  dragOriginPosition = transform.position;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// While the card is being lifted, we do not want it to be draggable.</span>
</span></span><span style=display:flex><span>  IsDraggable = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// We create a Tween to change the height of the card.</span>
</span></span><span style=display:flex><span>  TweenFloat.Create()
</span></span><span style=display:flex><span>    .Origin(dragOriginPosition.y)   <span style=color:#75715e>// Origin.</span>
</span></span><span style=display:flex><span>    .Destination(position.y)        <span style=color:#75715e>// Destination.</span>
</span></span><span style=display:flex><span>    .Duration(riseDuration)         <span style=color:#75715e>// Duration.</span>
</span></span><span style=display:flex><span>    .EasingIn(riseEaseIn)           <span style=color:#75715e>// Initial Easing function.</span>
</span></span><span style=display:flex><span>    .EasingOut(riseEaseOut)         <span style=color:#75715e>// Final Easing function.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This is where the position is modified.</span>
</span></span><span style=display:flex><span>    .OnUpdate(tween =&gt; transform.position =
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>new</span> Vector3(transform.position.x,
</span></span><span style=display:flex><span>                  tween.Value,      <span style=color:#75715e>// Only the height.</span>
</span></span><span style=display:flex><span>                  transform.position.z))
</span></span><span style=display:flex><span>    .OnEnd(_ =&gt; IsDraggable = <span style=color:#66d9ef>true</span>) <span style=color:#75715e>// When finished,</span>
</span></span><span style=display:flex><span>                                    <span style=color:#75715e>// it becomes draggable again.</span>
</span></span><span style=display:flex><span>    .Start();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And this would be the result:</p><p><img src=/Dawn-Of-The-Cards/images/dragging_and_dropping_3d_cards/dragdrop.gif alt="Drag Drop" title="Drag Drop"></p><p>Much better! And only adding one file! ;)</p><p>Let&rsquo;s apply the same change to how the card moves. Right now it&rsquo;s very static, it looks like it&rsquo;s moving in a vacuum. We can exaggerate the friction of a flexible object moving in the air and rotate the cards depending on their direction and speed. You may have seen this effect in games such as &lsquo;<a href=https://hearthstone.blizzard.com/>Hearthstone</a>&rsquo;.</p><p>We are going to modify the angles of the card according to its velocity vector. Specifically we will change the <strong>pitch</strong> and <strong>roll</strong>.</p><p><img src=/Dawn-Of-The-Cards/images/dragging_and_dropping_3d_cards/axis.png alt=Axis title=Axis></p><p>Each axis will have a <strong>force</strong> that will be applied to modify that axis. We will also limit the <strong>range</strong> of the angles. And finally a time that will be the time it takes for the axes to return to their original value.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#a6e22e>[Header(&#34;Pitch&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[SerializeField, Label(&#34;Force&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>float</span> pitchForce = <span style=color:#ae81ff>10.0f</span>;  
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[SerializeField, Label(&#34;Minimum Angle&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>float</span> pitchMinAngle = -<span style=color:#ae81ff>25.0f</span>;  
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[SerializeField, Label(&#34;Maximum Angle&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>float</span> pitchMaxAngle = <span style=color:#ae81ff>25.0f</span>;  
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[Space]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[Header(&#34;Roll&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[SerializeField, Label(&#34;Force&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>float</span> rollForce = <span style=color:#ae81ff>10.0f</span>;  
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[SerializeField, Label(&#34;Minimum Angle&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>float</span> rollMinAngle = -<span style=color:#ae81ff>25.0f</span>;  
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[SerializeField, Label(&#34;Maximum Angle&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>float</span> rollMaxAngle = <span style=color:#ae81ff>25.0f</span>;  
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[Space]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[SerializeField]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>float</span> restTime = <span style=color:#ae81ff>1.0f</span>;  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Pitch angle and velocity.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>float</span> pitchAngle, pitchVelocity;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Roll angle and velocity.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>float</span> rollAngle, rollVelocity;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// To calculate the velocity vector.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> Vector3 oldPosition;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// The original rotation</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> Vector3 originalAngles;
</span></span></code></pre></div><p>In each frame we must calculate:</p><ul><li>The velocity vector, or offset, of the card.</li><li>Calculate the pitch and roll depending on each axis and its force (<strong>pitchForce</strong> and <strong>rollForce</strong>).</li><li>Limit the angles to the valid ranges.</li><li>Calculate the angles and over time (<strong>restTime</strong>) tend to zero.</li><li>Apply the angles to the rotation of the card.</li></ul><p>The offset vector is very simple, just subtract the current position from the position of the previous frame.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span>Vector3 currentPosition = transform.position;
</span></span><span style=display:flex><span>Vector3 offset = currentPosition - oldPosition;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>oldPosition = currentPosition;
</span></span></code></pre></div><p>To rule out small vibrations, we will only calculate the angles when the modulus of <strong>offset</strong> is greater than <a href=https://docs.unity3d.com/ScriptReference/Mathf.Epsilon.html>Mathf.Epsilon</a> (which is a value very close to zero). And since we don&rsquo;t care about the actual value of the modulus, we will use <a href=https://docs.unity3d.com/ScriptReference/Vector3-sqrMagnitude.html>Vector3.sqrMagnitude</a> to avoid calculating a square root.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#66d9ef>if</span> (offset.sqrMagnitude &gt; Mathf.Epsilon)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  pitchAngle = Mathf.Clamp(pitchAngle + offset.z * pitchForce,
</span></span><span style=display:flex><span>                           pitchMinAngle,
</span></span><span style=display:flex><span>                           pitchMaxAngle);
</span></span><span style=display:flex><span>  rollAngle = Mathf.Clamp(rollAngle + offset.x * rollForce,
</span></span><span style=display:flex><span>                          rollMinAngle,
</span></span><span style=display:flex><span>                          rollMaxAngle);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We already have the value of each angle, now we want that little by little those values tend to be at rest (<strong>restTime</strong>). To do it we will use the function <a href=https://docs.unity3d.com/ScriptReference/Mathf.SmoothDamp.html>Mathf.SmoothDamp</a> that also smooths the changes.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span>pitchAngle = Mathf.SmoothDamp(pitchAngle,
</span></span><span style=display:flex><span>                              <span style=color:#ae81ff>0.0f</span>,
</span></span><span style=display:flex><span>                              <span style=color:#66d9ef>ref</span> pitchVelocity,
</span></span><span style=display:flex><span>                              restTime * Time.deltaTime * <span style=color:#ae81ff>10.0f</span>);
</span></span><span style=display:flex><span>rollAngle = Mathf.SmoothDamp(rollAngle,
</span></span><span style=display:flex><span>                             <span style=color:#ae81ff>0.0f</span>,
</span></span><span style=display:flex><span>                             <span style=color:#66d9ef>ref</span> rollVelocity,
</span></span><span style=display:flex><span>                             restTime * Time.deltaTime * <span style=color:#ae81ff>10.0f</span>);
</span></span></code></pre></div><p>And now we only have to apply the angles to the rotation of the card.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span>transform.rotation = Quaternion.Euler(originalAngles.x + pitchAngle,
</span></span><span style=display:flex><span>                                      originalAngles.y,
</span></span><span style=display:flex><span>                                      originalAngles.z - rollAngle);
</span></span></code></pre></div><p>Let&rsquo;s see the result.</p><p><img src=/Dawn-Of-The-Cards/images/dragging_and_dropping_3d_cards/tilt.gif alt=Tilt title=Tilt></p><p>Nice! That&rsquo;s all for now. In next posts we will see some useful objects for a card game such as: decks, slot, etc. In the meantime you can add some improvements like:</p><ul><li>Choose which Easing functions to use to pick up cards and drop them. I am using Quart/Back to pick them up and Quart/Bounce to drop them.</li><li>Add some dust particles when dropping a card.</li><li>Add a camera shake when dropping a card to give it more drama.</li><li>And&mldr; can you think of anything else? I&rsquo;d love to read about it in the comments.</li></ul><p>Until next time&mldr; <strong>stay gamedev, stay awesome!</strong></p><blockquote><p><a href=https://gist.github.com/FronkonGames/e14d6f02fe90df7a2e212b11ee2f0a3c>üì• DRAG AND DROP CODE üì•</a></p></blockquote></div><div class="footer no-tags"></div></article></div><div id=comments-container><script src=https://giscus.app/client.js data-repo=FronkonGames/Dawn-Of-The-Cards data-repo-id=R_kgDOHxLLYA data-category=Devblog data-category-id=DIC_kwDOHxLLYM4CQpcc data-mapping=pathname data-reactions-enabled=1 data-emit-metadata data-theme=preferred_color_scheme data-lang=en crossorigin=anonymous async></script><div id=giscus></div></div></div><footer><div class=container><div class=recent-posts><strong>Latest posts</strong><ul><li><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/unity_is_a_harsh_mistress/>Unity is a harsh mistress üíî</a></li><li><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/dragging_and_dropping_3d_cards/>Dragging And Dropping 3D Cards üÉè</a></li><li><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/rendering_a_card/>Rendering A Card In URP üñåÔ∏è</a></li><li><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/making_a_3d_card_in_blender/>Making A 3D Card In Blender üÉè</a></li><li><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/hello_everybody/>Hello Everybody! üßü</a></li><li><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/archive/>Archive page</a></li></ul></div><div class=right><div class=external-profiles><strong>Social media</strong>
<a href=https://twitter.com/fronkongames target=_blank><i class="fab fa-twitter"></i></a>
<a href=https://github.com/FronkonGames target=_blank><i class="fab fa-github"></i></a></div></div></div></footer><div class=credits><div class=container><div class=copyright><a href=https://fronkongames.github.io/ target=_blank>&copy;
2023
by Fronkon Games</a></div><div class=author><a href=https://github.com/Lednerb/bilberry-hugo-theme target=_blank>Bilberry Hugo Theme</a></div></div></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-7SGJ6HWLSZ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7SGJ6HWLSZ",{anonymize_ip:!1})}</script><script src=https://fronkongames.github.io/Dawn-Of-The-Cards/theme.js></script><div id=activate-algolia-search class=hidden><input type=hidden id=algolia-search-appId value=45CEN6X6AT>
<input type=hidden id=algolia-search-apiKey value=16030625f1a4d0dd3b8aefd794fd4cf1>
<input type=hidden id=algolia-search-indexName value=bilberry-hugo-theme>
<input type=hidden id=algolia-search-noSearchResults value="Nothing found.">
<input type=hidden id=algolia-search-currentLanguageOnly></div></body></html>