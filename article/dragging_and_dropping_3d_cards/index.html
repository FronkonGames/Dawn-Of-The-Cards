<!doctype html><html itemscope itemtype=https://schema.org/WebPage class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=siteBaseUrl content="https://fronkongames.github.io/Dawn-Of-The-Cards/"><meta name=author content="Martin Bustos"><meta name=description content="A devblog about the development of 'Dawn Of The Cards'."><meta name=keywords content="devblog,blog,gamedev,gamedevelopment,indiedev,unity,unity3d,roguelike,deckbuilding,zombie,zombies,dawn,cards"><meta name=generator content="Hugo 0.105.0"><title>Dragging And Dropping 3D Cards üÉè | Dawn Of The Cards - Fronkon Games</title><meta itemprop=name content="Dragging And Dropping 3D Cards üÉè"><meta itemprop=description content="Dragging And Dropping 3D Cards üÉè - A devblog about the development of 'Dawn Of The Cards'."><meta property="og:title" content="Dragging And Dropping 3D Cards üÉè"><meta property="og:description" content="Dragging And Dropping 3D Cards üÉè - A devblog about the development of 'Dawn Of The Cards'."><meta property="og:image" content="https://www.gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e?size=200"><meta property="og:url" content="https://fronkongames.github.io/Dawn-Of-The-Cards/article/dragging_and_dropping_3d_cards/"><meta property="og:site_name" content="Dawn Of The Cards - Fronkon Games"><meta property="og:type" content="article"><link rel=apple-touch-icon sizes=152x152 href=/Dawn-Of-The-Cards/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/Dawn-Of-The-Cards/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/Dawn-Of-The-Cards/favicon-16x16.png><link rel=manifest href=/Dawn-Of-The-Cards/site.webmanifest><link rel=mask-icon href=/Dawn-Of-The-Cards/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><script src=/Dawn-Of-The-Cards/modernizr-simple.js></script>
<link href=/Dawn-Of-The-Cards/article/dragging_and_dropping_3d_cards/ rel=alternate type=application/rss+xml title="Dawn Of The Cards - Fronkon Games"><link href=/Dawn-Of-The-Cards/article/dragging_and_dropping_3d_cards/ rel=feed type=application/rss+xml title="Dawn Of The Cards - Fronkon Games"><link rel=canonical href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/dragging_and_dropping_3d_cards/><link rel=stylesheet href=https://fronkongames.github.io/Dawn-Of-The-Cards/theme.css></head><body class=bilberry-hugo-theme><header style=background-image:url(/Dawn-Of-The-Cards/images/header.png);background-repeat:no-repeat;background-position:50%;width:100%;height:fit-content><div class=container style=height:400px><div class=logo style=margin-top:250px><a href=/Dawn-Of-The-Cards class=logo><img src="https://seccdn.libravatar.org/avatar/23f0a74e9bc0a5eb8500a54f0729e295?d=mm&size=200" alt>
<span class=overlay><i class="fa fa-home"></i></span></a></div></div></header><div class="main container"><div class="article-wrapper u-cf single"><a class=bubble href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/dragging_and_dropping_3d_cards/><i class="fas fa-fw fa-pencil-alt"></i></a><article class="default article"><div class=content><h1 class=article-title><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/dragging_and_dropping_3d_cards/>Dragging And Dropping 3D Cards üÉè</a></h1><div class=meta></div><p><img src=/Dawn-Of-The-Cards/images/dragging_and_dropping_3d_cards/promo.gif alt=Promo title=Promo></p><p>Moving cards, with elegance.</p><p>Now that I have defined <a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/rendering_a_card/>visually a card</a>, the next thing to do is to move it around the scene.</p><p>To do this we first have to detect the cards. We will do this using the &lsquo;<strong>Raycast</strong>&rsquo; functions, which <strong>fire</strong> rays that when colliding with an object give us information about it.</p><p>Since it is a performance consuming operation, we will use some tricks to optimize it. The first one is that we will create a <a href=https://docs.unity3d.com/Manual/use-layers.html>layer</a> to discard objects that are not involved in the operation. We will named it &lsquo;<strong>DragAndDrop</strong>&rsquo;.</p><p><img src=/Dawn-Of-The-Cards/images/dragging_and_dropping_3d_cards/layers.jpg alt=Layers title=Layers></p><p>We will also limit the ray length to the maximum distance our camera sees, since as a general rule we are not interested in objects we are not going to see. This distance is &lsquo;<strong>Camera.main.farClipPlane</strong>&rsquo;.</p><p>Since the &lsquo;<strong>Raycast</strong>&rsquo; operation is going to be used inside the &lsquo;<strong>Update</strong>&rsquo; loop (it is going to be executed every frame), it is always a good idea to avoid allocating memory if we can avoid it. So we will create a <a href=https://docs.unity3d.com/ScriptReference/Ray.html>Ray</a> and use the function <a href=https://docs.unity3d.com/ScriptReference/Physics.RaycastNonAlloc.html>Physics.RaycastNonAlloc</a>.</p><p>The code to detect the cards would look something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span>  <span style=color:#75715e>// Layer of the objects to be detected.</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>  [SerializeField]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> LayerMask raycastMask;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// How many impacts of the beam we want to obtain.</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> HitsCount = <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Information on the impacts of shooting a ray.</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> RaycastHit[] raycastHits = <span style=color:#66d9ef>new</span> RaycastHit[HitsCount];
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Ray created from the camera to the projection of the mouse</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// coordinates on the scene.</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> Ray mouseRay;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// Returns the Transfrom of the object closest to the origin</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// of the ray.</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;returns&gt;Transform or null if there is no impact.&lt;/returns&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> Transform MouseRaycast()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    Transform hit = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Fire the ray!</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Physics.RaycastNonAlloc(mouseRay,
</span></span><span style=display:flex><span>                                raycastHits,
</span></span><span style=display:flex><span>                                Camera.main.farClipPlane,
</span></span><span style=display:flex><span>                                raycastMask) &gt; <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// We order the impacts according to distance.</span>
</span></span><span style=display:flex><span>      System.Array.Sort(raycastHits,
</span></span><span style=display:flex><span>                        (x, y) =&gt; x.distance.CompareTo(y.distance));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// We are only interested in the first one.</span>
</span></span><span style=display:flex><span>      hit = raycastHits[<span style=color:#ae81ff>0</span>].transform;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> hit;
</span></span><span style=display:flex><span>  }  
</span></span></code></pre></div><p>Before calling this function, we must update &lsquo;<strong>mouseRay</strong>&rsquo; with the mouse coordinates. We will do it with this code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span>  mouseRay = Camera.main.ScreenPointToRay(Input.mousePosition);
</span></span></code></pre></div><blockquote><p>‚ö†Ô∏è <strong>In this post I will use the old <a href=https://docs.unity3d.com/ScriptReference/Input.html>Input</a> for simplicity, but it is recommended to use the new <a href=https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/QuickStartGuide.html>Input System</a>.</strong> ‚ö†Ô∏è</p></blockquote><p>In order to get all this to work on a card, we must first add a &lsquo;<a href=https://docs.unity3d.com/ScriptReference/Collider.html>Collider</a>&rsquo;. Without this component, our ray would pass through the card without detecting it. A &lsquo;<a href=https://docs.unity3d.com/Manual/class-BoxCollider.html>Box Collider</a>&rsquo; is a good choice for the type of geometry of a card, but if you need more precision you can use a &lsquo;<a href=https://docs.unity3d.com/Manual/class-MeshCollider.html>Mesh Collider</a>&rsquo;.</p><p>The second thing to do is to assign the &lsquo;<strong>layer</strong>&rsquo; we have selected to the chart. We are now ready to detect a card.</p><p><img src=/Dawn-Of-The-Cards/images/dragging_and_dropping_3d_cards/rayhit.gif alt="Ray hit" title="Ray Hit"></p><p>Now we can start moving our cards. First we are going to define two interfaces, the first one is <strong>IDrag</strong>, for objects that you can drag.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// Draggable object.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IDrag</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt; Can it be draggable? &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsDraggable { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt; A Drag operation is currently underway. &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> Dragging { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt; Mouse enters the object. &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;position&#34;&gt;Mouse position.&lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnPointerEnter(Vector3 position);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt; Mouse exits object. &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;position&#34;&gt;Mouse position.&lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnPointerExit(Vector3 position);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt; Drag begins. &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;position&#34;&gt;Mouse position.&lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnBeginDrag(Vector3 position);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt;A drag is being made. &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;deltaPosition&#34;&gt; Mouse offset position. &lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;droppable&#34;&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// Object on which a drop may be made, or null. &lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnDrag(Vector3 deltaPosition, IDrop droppable);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt; The drag operation is completed. &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;position&#34;&gt;Mouse position.&lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;droppable&#34;&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// Object on which a drop may be made, or null. &lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnEndDrag(Vector3 position, IDrop droppable);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And the second is <strong>IDrop</strong>, for objects that can accept IDrag objects.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// Accept draggable objects.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IDrop</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt; Is it droppable? &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> IsDroppable { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt; Accept an IDrag? &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;drag&#34;&gt;Object IDrag.&lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;returns&gt;Accept or not the object.&lt;/returns&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> AcceptDrop(IDrag drag);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;summary&gt; Performs the drop operation of an IDrag object. &lt;/summary&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/// &lt;param name=&#34;drag&#34;&gt;Object IDrag.&lt;/param&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnDrop(IDrag drag);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As you can see, it is <strong>IDrop</strong> that will authorize an <strong>IDrag</strong>, with its <strong>AcceptDrop</strong> method, whether or not to accept a drop operation to be executed on it.</p><p>With these two interfaces ready we can start with the one in charge of handling the drag and drop operations of our cards. We can call it &lsquo;<strong>DragAndDropManager</strong>&rsquo; and will be a <a href=https://docs.unity3d.com/ScriptReference/MonoBehaviour.html>MonoBehaviour</a>. An operation of drag & drop operation can be divided into:</p><ol><li>There is no drag operation at present.</li></ol><ul><li>Cards must be detected under the mouse pointer.<ul><li>If a card is detected and the left mouse button is pressed, a drag operation is started and the <strong>OnBeginDrag</strong> method must be called.</li><li>If there is a detected card and no button is being pressed, the <strong>OnPointerEnter</strong> and <strong>OnPointerExit</strong> methods of the detected card are called.</li></ul></li></ul><ol start=2><li>A drag operation is in progress.</li></ol><ul><li>If the left mouse button is pressed, the card should be moved and the <strong>OnDrag</strong> method should be called.</li><li>If it is not, the drag operation must be finished and the <strong>OnEndDrag</strong> method must be called.</li></ul><blockquote><p>‚ö†Ô∏è <strong>All the code in this article is designed to move the cards in the XZ plane and use the Y axis for the height. If you use different axes you will have to modify the code.</strong> ‚ö†Ô∏è</p></blockquote><p>All this will have to be done in each frame, so it will be done inside the function &lsquo;<strong>Update</strong>&rsquo; of &lsquo;<strong>DragAndDropManager</strong>&rsquo;. We will use these variables:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>// Height at which we want the card to be in a drag operation.</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[SerializeField, Range(0.0f, 10.0f)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>float</span> height = <span style=color:#ae81ff>1.0f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Object to which we are doing a drag operation</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// or null if no drag operation currently exists.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> IDrag currentDrag;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// IDrag objects that the mouse passes over.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> IDrag possibleDrag;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// To know the position of the drag object.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> Transform currentDragTransform;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// To calculate the mouse offset (in world-space).</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> Vector3 oldMouseWorldPosition;
</span></span></code></pre></div><p>Let&rsquo;s see how to detect an <strong>IDrag</strong>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>/// &lt;summary&gt;Detects an IDrag object under the mouse pointer.&lt;/summary&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// &lt;returns&gt;IDrag or null.&lt;/returns&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> IDrag DetectDraggable()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  IDrag draggable = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  mouseRay = Camera.main.ScreenPointToRay(Input.mousePosition);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Transform hit = MouseRaycast();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (hit != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    draggable = hit.GetComponent&lt;IDrag&gt;();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (draggable <span style=color:#66d9ef>is</span> { IsDraggable: <span style=color:#66d9ef>false</span> })
</span></span><span style=display:flex><span>      draggable = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> draggable;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now there are two possibilities, that the left mouse button is pressed or not pressed. If it is pressed and there is an <strong>IDrag</strong> object under the mouse pointer:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span>IDrag draggable = DetectDraggable();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Left mouse button pressed?</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (Input.GetMouseButtonDown(<span style=color:#ae81ff>0</span>) == <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Is there an IDrag object under the mouse pointer?</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (draggable != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We already have an object to start the drag operation!</span>
</span></span><span style=display:flex><span>    currentDrag = draggable;
</span></span><span style=display:flex><span>    currentDragTransform = hit;
</span></span><span style=display:flex><span>    oldMouseWorldPosition = MousePositionToWorldPoint();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Hide the mouse icon.</span>
</span></span><span style=display:flex><span>    Cursor.visible = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// And we lock the movements to the window frame,</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// so we can&#39;t move objects out of the camera&#39;s view.</span>
</span></span><span style=display:flex><span>    Cursor.lockState = CursorLockMode.Confined;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The drag operation begins.</span>
</span></span><span style=display:flex><span>    currentDrag.Dragging = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    currentDrag.OnBeginDrag(<span style=color:#66d9ef>new</span> Vector3(raycastHits[<span style=color:#ae81ff>0</span>].point.x,
</span></span><span style=display:flex><span>                                        raycastHits[<span style=color:#ae81ff>0</span>].point.y + height,
</span></span><span style=display:flex><span>                                        raycastHits[<span style=color:#ae81ff>0</span>].point.z));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And if the left mouse button is not pressed:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#75715e>// Left mouse button not pressed?</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (Input.GetMouseButtonDown(<span style=color:#ae81ff>0</span>) == <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>// We pass over a new IDrag?</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (draggable != <span style=color:#66d9ef>null</span> &amp;&amp; possibleDrag == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We execute its OnPointerEnter.</span>
</span></span><span style=display:flex><span>    possibleDrag = draggable;
</span></span><span style=display:flex><span>    possibleDrag.OnPointerEnter(raycastHits[<span style=color:#ae81ff>0</span>].point);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// We are leaving an IDrag?</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (draggable == <span style=color:#66d9ef>null</span> &amp;&amp; possibleDrag != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We execute its OnPointerExit.</span>
</span></span><span style=display:flex><span>    possibleDrag.OnPointerExit(raycastHits[<span style=color:#ae81ff>0</span>].point);
</span></span><span style=display:flex><span>    possibleDrag = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We already have the first part, now let&rsquo;s go for the second part: to handle a drag operation. The first thing we will do is a new method that will return the <strong>IDrop</strong> that is under a card. It&rsquo;s not as simple as &lsquo;<strong>DetectDraggable()</strong>&rsquo;, since a card has a surface and can be on several objects at once. We will need to cast four rays, one for each corner. And to choose one, we will order the
hits by proximity to the center of the card, this way we will get the <strong>IDrop</strong> object that is on the card and is the closest to it.</p><p>We will store the rays hits in a variable of type &lsquo;<a href=https://learn.microsoft.com/dotnet/api/system.collections.generic.sortedset-1>SortedSet</a>&rsquo; to which we will set a custom sorting function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ComparerCardDistance</span> : IComparer&lt;Transform&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Compare(Transform a, Transform b) =&gt; a.position.sqrMagnitude.CompareTo(b.position.sqrMagnitude);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> SortedSet&lt;Transform&gt; cardHits = <span style=color:#66d9ef>new</span>(<span style=color:#66d9ef>new</span> ComparerCardDistance());
</span></span></code></pre></div><p>In &lsquo;<strong>cardHits</strong>&rsquo; will store the following function the results of rays hits:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>bool</span> CardRaycast()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  Transform hit = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>  Vector3 cardPosition = currentDragTransform.position; 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Vector3[] cardConner =
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span>(cardPosition.x + cardSize.x * <span style=color:#ae81ff>0.5f</span>, cardPosition.y, cardPosition.z - cardSize.y * <span style=color:#ae81ff>0.5f</span>),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span>(cardPosition.x + cardSize.x * <span style=color:#ae81ff>0.5f</span>, cardPosition.y, cardPosition.z + cardSize.y * <span style=color:#ae81ff>0.5f</span>),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span>(cardPosition.x - cardSize.x * <span style=color:#ae81ff>0.5f</span>, cardPosition.y, cardPosition.z - cardSize.y * <span style=color:#ae81ff>0.5f</span>),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span>(cardPosition.x - cardSize.x * <span style=color:#ae81ff>0.5f</span>, cardPosition.y, cardPosition.z + cardSize.y * <span style=color:#ae81ff>0.5f</span>)
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  cardHits.Clear();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; cardConner.Length; ++i)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    Ray ray = <span style=color:#66d9ef>new</span>(cardConner[i], Vector3.down);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Physics.RaycastNonAlloc(ray, raycastHits, Camera.main.farClipPlane, raycastMask) &gt; <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      System.Array.Sort(raycastHits, (x, y) =&gt; x.distance.CompareTo(y.distance));
</span></span><span style=display:flex><span>      hit = raycastHits[<span style=color:#ae81ff>0</span>].transform;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (cardHits.Contains(raycastHits[<span style=color:#ae81ff>0</span>].transform) == <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>        cardHits.Add(raycastHits[<span style=color:#ae81ff>0</span>].transform);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> cardHits.Count &gt; <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s see it in action:</p><p><img src=/Dawn-Of-The-Cards/images/dragging_and_dropping_3d_cards/cardhits.gif alt="Card hits" title="Card Hits"></p><p><strong>üöß WORK IN PROGRESS üöß</strong></p></div><div class="footer no-tags"></div></article></div><div id=comments-container><script src=https://giscus.app/client.js data-repo=FronkonGames/Dawn-Of-The-Cards data-repo-id=R_kgDOHxLLYA data-category=Devblog data-category-id=DIC_kwDOHxLLYM4CQpcc data-mapping=pathname data-reactions-enabled=1 data-emit-metadata data-theme=preferred_color_scheme data-lang=en crossorigin=anonymous async></script><div id=giscus></div></div></div><footer><div class=container><div class=recent-posts><strong>Latest posts</strong><ul><li><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/dragging_and_dropping_3d_cards/>Dragging And Dropping 3D Cards üÉè</a></li><li><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/rendering_a_card/>Rendering A Card In URP üñåÔ∏è</a></li><li><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/making_a_3d_card_in_blender/>Making A 3D Card In Blender üÉè</a></li><li><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/article/hello_everybody/>Hello Everybody! üßü</a></li><li><a href=https://fronkongames.github.io/Dawn-Of-The-Cards/archive/>Archive page</a></li></ul></div><div class=right><div class=external-profiles><strong>Social media</strong>
<a href=https://twitter.com/fronkongames target=_blank><i class="fab fa-twitter"></i></a>
<a href=https://github.com/FronkonGames target=_blank><i class="fab fa-github"></i></a></div></div></div></footer><div class=credits><div class=container><div class=copyright><a href=https://fronkongames.github.io/ target=_blank>&copy;
2022
by Fronkon Games</a></div><div class=author><a href=https://github.com/Lednerb/bilberry-hugo-theme target=_blank>Bilberry Hugo Theme</a></div></div></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-7SGJ6HWLSZ"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7SGJ6HWLSZ",{anonymize_ip:!1})}</script><script src=https://fronkongames.github.io/Dawn-Of-The-Cards/theme.js></script><div id=activate-algolia-search class=hidden><input type=hidden id=algolia-search-appId value=45CEN6X6AT>
<input type=hidden id=algolia-search-apiKey value=16030625f1a4d0dd3b8aefd794fd4cf1>
<input type=hidden id=algolia-search-indexName value=bilberry-hugo-theme>
<input type=hidden id=algolia-search-noSearchResults value="Nothing found.">
<input type=hidden id=algolia-search-currentLanguageOnly></div></body></html>